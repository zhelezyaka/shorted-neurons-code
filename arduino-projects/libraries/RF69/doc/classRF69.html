<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.5"/>
<title>RF69: RF69 Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">RF69
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.5 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classRF69-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">RF69 Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Send and receive unaddressed, unreliable datagrams.  
 <a href="classRF69.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="RF69_8h_source.html">RF69.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structRF69_1_1ModemConfig.html">ModemConfig</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines register values for a set of modem configuration registers.  <a href="structRF69_1_1ModemConfig.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4fe41b1fe75743906fa8501961ba6e6c"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#a4fe41b1fe75743906fa8501961ba6e6c">ModemConfigChoice</a> { <br/>
&#160;&#160;<a class="el" href="classRF69.html#a4fe41b1fe75743906fa8501961ba6e6cabd5e2fe19f3efc50f97d825bc2694be7">FSK_Rb2Fd5</a> = 0, 
<a class="el" href="classRF69.html#a4fe41b1fe75743906fa8501961ba6e6ca7af1950ac5b3a5a684a8f61e5df65e7a">FSK_Rb2_4Fd2_4</a>, 
<a class="el" href="classRF69.html#a4fe41b1fe75743906fa8501961ba6e6ca8710e687d9dd463a00048565782489c6">FSK_Rb4_8Fd4_8</a>, 
<a class="el" href="classRF69.html#a4fe41b1fe75743906fa8501961ba6e6ca1241c5f1226a7ab7be2a202d54de6e56">FSK_Rb9_6Fd9_6</a>, 
<br/>
&#160;&#160;<a class="el" href="classRF69.html#a4fe41b1fe75743906fa8501961ba6e6ca115c8736a443b2828e3fbe23cc10692f">FSK_Rb19_2Fd19_2</a>, 
<a class="el" href="classRF69.html#a4fe41b1fe75743906fa8501961ba6e6ca61b026d8fb0a9fd0758f55f1c1dc04a6">FSK_Rb38_4Fd38_4</a>, 
<a class="el" href="classRF69.html#a4fe41b1fe75743906fa8501961ba6e6ca7f5ef500cb6713a46c760918d356a9b7">FSK_Rb57_6Fd120</a>, 
<a class="el" href="classRF69.html#a4fe41b1fe75743906fa8501961ba6e6ca058590d23a8119ae285685525546e3b3">FSK_Rb125Fd125</a>, 
<br/>
&#160;&#160;<a class="el" href="classRF69.html#a4fe41b1fe75743906fa8501961ba6e6ca95e753e72e2d61da7b04740b15879aea">FSK_Rb250Fd250</a>, 
<a class="el" href="classRF69.html#a4fe41b1fe75743906fa8501961ba6e6cab3e03baa1f07b8604e0b7fb67b079116">FSK_Rb55555Fd50</a>, 
<a class="el" href="classRF69.html#a4fe41b1fe75743906fa8501961ba6e6ca6898fa56805d7855633b1ff97d0e1948">FSK_Rb_512Fd2_5</a>, 
<a class="el" href="classRF69.html#a4fe41b1fe75743906fa8501961ba6e6caabce6b1ca98878dd76a52c4f75f32b73">GFSK_Rb2Fd5</a>, 
<br/>
&#160;&#160;<a class="el" href="classRF69.html#a4fe41b1fe75743906fa8501961ba6e6cacc7c02340dac35e890ba461085f4f074">GFSK_Rb2_4Fd2_4</a>, 
<a class="el" href="classRF69.html#a4fe41b1fe75743906fa8501961ba6e6cac8d2080ca9afb27a08653ee667b90ea2">GFSK_Rb4_8Fd4_8</a>, 
<a class="el" href="classRF69.html#a4fe41b1fe75743906fa8501961ba6e6caf393f278340847169df3b8657a0db500">GFSK_Rb9_6Fd9_6</a>, 
<a class="el" href="classRF69.html#a4fe41b1fe75743906fa8501961ba6e6ca23b25283ff64ae1cdc0c49b70ea3c5f2">GFSK_Rb19_2Fd19_2</a>, 
<br/>
&#160;&#160;<a class="el" href="classRF69.html#a4fe41b1fe75743906fa8501961ba6e6caac3d963dd38ade38b3c57c8b6abc7042">GFSK_Rb38_4Fd38_4</a>, 
<a class="el" href="classRF69.html#a4fe41b1fe75743906fa8501961ba6e6cae5fa7382aa009ee2310eb8ef76d438f0">GFSK_Rb57_6Fd120</a>, 
<a class="el" href="classRF69.html#a4fe41b1fe75743906fa8501961ba6e6ca89511e57ffa756795a47e3f8de0c6703">GFSK_Rb125Fd125</a>, 
<a class="el" href="classRF69.html#a4fe41b1fe75743906fa8501961ba6e6cacb1eb1dd9da5ef0e3b1973e95d7e0342">GFSK_Rb250Fd250</a>, 
<br/>
&#160;&#160;<a class="el" href="classRF69.html#a4fe41b1fe75743906fa8501961ba6e6cacd8a65a8d1c24266bfbe94c3af8d7571">GFSK_Rb55555Fd50</a>
<br/>
 }</td></tr>
<tr class="separator:a4fe41b1fe75743906fa8501961ba6e6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a049055ffc82e4cbf172888ef8d9fec50"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#a049055ffc82e4cbf172888ef8d9fec50">RF69</a> (uint8_t slaveSelectPin=SS, uint8_t interrupt=0, <a class="el" href="classGenericSPIClass.html">GenericSPIClass</a> *spi=&amp;Hardware_spi)</td></tr>
<tr class="separator:a049055ffc82e4cbf172888ef8d9fec50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa9c067942baee08116409afe2b67c24"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#afa9c067942baee08116409afe2b67c24">init</a> ()</td></tr>
<tr class="separator:afa9c067942baee08116409afe2b67c24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af953ee17aca5392f1e62ea4fe690550a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#af953ee17aca5392f1e62ea4fe690550a">reset</a> ()</td></tr>
<tr class="separator:af953ee17aca5392f1e62ea4fe690550a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d194034f90f5cf0d41d5d05856dcf86"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#a6d194034f90f5cf0d41d5d05856dcf86">spiRead</a> (uint8_t reg)</td></tr>
<tr class="separator:a6d194034f90f5cf0d41d5d05856dcf86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892117259efd9135448bee5529a31ac8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#a892117259efd9135448bee5529a31ac8">spiWrite</a> (uint8_t reg, uint8_t val)</td></tr>
<tr class="separator:a892117259efd9135448bee5529a31ac8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9ec98fc751bc26e9c009251c42da9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#a9e9ec98fc751bc26e9c009251c42da9e">spiBurstRead</a> (uint8_t reg, uint8_t *dest, uint8_t len)</td></tr>
<tr class="separator:a9e9ec98fc751bc26e9c009251c42da9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb0340012327cddd9e502cbe33ca7cf9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#abb0340012327cddd9e502cbe33ca7cf9">spiBurstWrite</a> (uint8_t reg, const uint8_t *src, uint8_t len)</td></tr>
<tr class="separator:abb0340012327cddd9e502cbe33ca7cf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbba30813b20d1b52aa540a3bb0838a7"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#adbba30813b20d1b52aa540a3bb0838a7">temperatureRead</a> ()</td></tr>
<tr class="separator:adbba30813b20d1b52aa540a3bb0838a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf68a80e6d95aaa543e4d26cb24c30d6"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#abf68a80e6d95aaa543e4d26cb24c30d6">setFrequency</a> (float centre, float afcPullInRange=0.05)</td></tr>
<tr class="separator:abf68a80e6d95aaa543e4d26cb24c30d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88c2534ddf80cb1df4b7c777c0d55e4"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#af88c2534ddf80cb1df4b7c777c0d55e4">rssiRead</a> ()</td></tr>
<tr class="separator:af88c2534ddf80cb1df4b7c777c0d55e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3cb25ebd64c7d4bc28317a5e482611a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#ab3cb25ebd64c7d4bc28317a5e482611a">setMode</a> (uint8_t <a class="el" href="classRF69.html#a29a0faf47121e8431f2ab03f60ca0b6c">mode</a>)</td></tr>
<tr class="separator:ab3cb25ebd64c7d4bc28317a5e482611a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad41e23fa6c86916ad9d31e43ed57a7da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#ad41e23fa6c86916ad9d31e43ed57a7da">setModeIdle</a> ()</td></tr>
<tr class="separator:ad41e23fa6c86916ad9d31e43ed57a7da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53c35921a0d9a17aed3876492bbfe5d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#a53c35921a0d9a17aed3876492bbfe5d1">setModeRx</a> ()</td></tr>
<tr class="separator:a53c35921a0d9a17aed3876492bbfe5d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7444f35ee3445dbf0d5e781b5e95738"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#ae7444f35ee3445dbf0d5e781b5e95738">setModeTx</a> ()</td></tr>
<tr class="separator:ae7444f35ee3445dbf0d5e781b5e95738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a0faf47121e8431f2ab03f60ca0b6c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#a29a0faf47121e8431f2ab03f60ca0b6c">mode</a> ()</td></tr>
<tr class="separator:a29a0faf47121e8431f2ab03f60ca0b6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b4adcf0c8bc0210dec7e98696dce596"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#a4b4adcf0c8bc0210dec7e98696dce596">setTxPower</a> (int8_t power)</td></tr>
<tr class="separator:a4b4adcf0c8bc0210dec7e98696dce596"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80e394fe440b16bf88014120da926254"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#a80e394fe440b16bf88014120da926254">setModemRegisters</a> (const <a class="el" href="structRF69_1_1ModemConfig.html">ModemConfig</a> *config)</td></tr>
<tr class="separator:a80e394fe440b16bf88014120da926254"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dd82b73f52f49f7bb31ab9c15feac3e"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#a7dd82b73f52f49f7bb31ab9c15feac3e">setModemConfig</a> (<a class="el" href="classRF69.html#a4fe41b1fe75743906fa8501961ba6e6c">ModemConfigChoice</a> index)</td></tr>
<tr class="separator:a7dd82b73f52f49f7bb31ab9c15feac3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c61cfa294c0b5acba1983bb32c21d22"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#a1c61cfa294c0b5acba1983bb32c21d22">available</a> ()</td></tr>
<tr class="separator:a1c61cfa294c0b5acba1983bb32c21d22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adee77eb9dcfc5e8e9c21bf279baae7f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#adee77eb9dcfc5e8e9c21bf279baae7f2">waitAvailable</a> ()</td></tr>
<tr class="separator:adee77eb9dcfc5e8e9c21bf279baae7f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9baf7e3b129c4309b845660bbc0fbae"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#ac9baf7e3b129c4309b845660bbc0fbae">waitAvailableTimeout</a> (uint16_t timeout)</td></tr>
<tr class="separator:ac9baf7e3b129c4309b845660bbc0fbae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fc06d71aaa24e9781bb8984b50dc6d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#a2fc06d71aaa24e9781bb8984b50dc6d8">setThisAddress</a> (uint8_t thisAddress)</td></tr>
<tr class="separator:a2fc06d71aaa24e9781bb8984b50dc6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff53e72d0c8c476ac42e37c8fc116795"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#aff53e72d0c8c476ac42e37c8fc116795">recv</a> (uint8_t *buf, uint8_t *len)</td></tr>
<tr class="separator:aff53e72d0c8c476ac42e37c8fc116795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabb5110b9710f0db13582fec63ed9635"><td class="memItemLeft" align="right" valign="top">boolean&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#aabb5110b9710f0db13582fec63ed9635">send</a> (const uint8_t *data, uint8_t len)</td></tr>
<tr class="separator:aabb5110b9710f0db13582fec63ed9635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a003312d212e2090b001c718ed96fb850"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#a003312d212e2090b001c718ed96fb850">waitPacketSent</a> ()</td></tr>
<tr class="separator:a003312d212e2090b001c718ed96fb850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c3e272a1e9c6fa68505828b7920425a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#a4c3e272a1e9c6fa68505828b7920425a">waitPacketSent</a> (uint16_t timeout)</td></tr>
<tr class="separator:a4c3e272a1e9c6fa68505828b7920425a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3d3e65d7e23374362fd2cd3bdf80a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#a6d3d3e65d7e23374362fd2cd3bdf80a8">setPromiscuous</a> (boolean promiscuous)</td></tr>
<tr class="separator:a6d3d3e65d7e23374362fd2cd3bdf80a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31f227bd90024c4e766d64dff05d1443"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#a31f227bd90024c4e766d64dff05d1443">headerTo</a> ()</td></tr>
<tr class="separator:a31f227bd90024c4e766d64dff05d1443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453dcbaa7090f63a45edf5ece0540f23"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#a453dcbaa7090f63a45edf5ece0540f23">headerFrom</a> ()</td></tr>
<tr class="separator:a453dcbaa7090f63a45edf5ece0540f23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd0d2d9449e29bb4708c420e108bd666"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#acd0d2d9449e29bb4708c420e108bd666">headerId</a> ()</td></tr>
<tr class="separator:acd0d2d9449e29bb4708c420e108bd666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98dc29671c54b7f0666dac3bc8670a9a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#a98dc29671c54b7f0666dac3bc8670a9a">headerFlags</a> ()</td></tr>
<tr class="separator:a98dc29671c54b7f0666dac3bc8670a9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c2c18a64a1e41d3e29b59809efccd78"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#a9c2c18a64a1e41d3e29b59809efccd78">lastRssi</a> ()</td></tr>
<tr class="separator:a9c2c18a64a1e41d3e29b59809efccd78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab953f1383c8c46e5cb69daa5e305d9f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#ab953f1383c8c46e5cb69daa5e305d9f7">setPreambleLength</a> (uint16_t bytes)</td></tr>
<tr class="separator:ab953f1383c8c46e5cb69daa5e305d9f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f0fb435fda7f4fd8c42230063c0c0e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#a3f0fb435fda7f4fd8c42230063c0c0e3">setSyncWords</a> (const uint8_t *syncWords=NULL, uint8_t len=0)</td></tr>
<tr class="separator:a3f0fb435fda7f4fd8c42230063c0c0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f683737fd051836e31c9f21be405d75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#a9f683737fd051836e31c9f21be405d75">setEncryptionKey</a> (uint8_t *key=NULL)</td></tr>
<tr class="separator:a9f683737fd051836e31c9f21be405d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a7fcc3f2b042d0173956d16690b056c64"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#a7fcc3f2b042d0173956d16690b056c64">printBuffer</a> (const char *prompt, const uint8_t *buf, uint8_t len)</td></tr>
<tr class="separator:a7fcc3f2b042d0173956d16690b056c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a73266d3e1faaae0449b11c6d99cf7f4f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#a73266d3e1faaae0449b11c6d99cf7f4f">handleInterrupt</a> ()</td></tr>
<tr class="separator:a73266d3e1faaae0449b11c6d99cf7f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad893bc05e3f4f246551bbdfb2c4206ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#ad893bc05e3f4f246551bbdfb2c4206ec">readFifo</a> ()</td></tr>
<tr class="separator:ad893bc05e3f4f246551bbdfb2c4206ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec70961e68478220352522bb4654ca1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#a2ec70961e68478220352522bb4654ca1">setHeaderTo</a> (uint8_t to)</td></tr>
<tr class="separator:a2ec70961e68478220352522bb4654ca1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af790da935407e77aff4699cf245fcd0f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#af790da935407e77aff4699cf245fcd0f">setHeaderFrom</a> (uint8_t from)</td></tr>
<tr class="separator:af790da935407e77aff4699cf245fcd0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ff30c728cb4b845d370e63937ac04f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#a8ff30c728cb4b845d370e63937ac04f2">setHeaderId</a> (uint8_t id)</td></tr>
<tr class="separator:a8ff30c728cb4b845d370e63937ac04f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b3a392f73cac36c5207516f53c3a00"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#a99b3a392f73cac36c5207516f53c3a00">setHeaderFlags</a> (uint8_t flags)</td></tr>
<tr class="separator:a99b3a392f73cac36c5207516f53c3a00"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a581cae4586b7c45789e6d0e3fe8af29a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a581cae4586b7c45789e6d0e3fe8af29a"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#a581cae4586b7c45789e6d0e3fe8af29a">isr0</a> ()</td></tr>
<tr class="memdesc:a581cae4586b7c45789e6d0e3fe8af29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low level interrupt service routine for <a class="el" href="classRF69.html" title="Send and receive unaddressed, unreliable datagrams. ">RF69</a> connected to interrupt 0. <br/></td></tr>
<tr class="separator:a581cae4586b7c45789e6d0e3fe8af29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3956c165111bfd20b62ff86cd89e488"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa3956c165111bfd20b62ff86cd89e488"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#aa3956c165111bfd20b62ff86cd89e488">isr1</a> ()</td></tr>
<tr class="memdesc:aa3956c165111bfd20b62ff86cd89e488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low level interrupt service routine for <a class="el" href="classRF69.html" title="Send and receive unaddressed, unreliable datagrams. ">RF69</a> connected to interrupt 1. <br/></td></tr>
<tr class="separator:aa3956c165111bfd20b62ff86cd89e488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33923ae2eabbf82ee828664621b11ae4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a33923ae2eabbf82ee828664621b11ae4"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#a33923ae2eabbf82ee828664621b11ae4">isr2</a> ()</td></tr>
<tr class="memdesc:a33923ae2eabbf82ee828664621b11ae4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Low level interrupt service routine for <a class="el" href="classRF69.html" title="Send and receive unaddressed, unreliable datagrams. ">RF69</a> connected to interrupt 1. <br/></td></tr>
<tr class="separator:a33923ae2eabbf82ee828664621b11ae4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a7fe77c62e5f8c6e3330ae701603288fc"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7fe77c62e5f8c6e3330ae701603288fc"></a>
<a class="el" href="classGenericSPIClass.html">GenericSPIClass</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>_spi</b></td></tr>
<tr class="separator:a7fe77c62e5f8c6e3330ae701603288fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb741b4cfbfb9dc2245a67f320b6b6e0"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="abb741b4cfbfb9dc2245a67f320b6b6e0"></a>
volatile uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>_mode</b></td></tr>
<tr class="separator:abb741b4cfbfb9dc2245a67f320b6b6e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab13ccdf7a20ff57c124d4af5a87c93f7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab13ccdf7a20ff57c124d4af5a87c93f7"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>_idleMode</b></td></tr>
<tr class="separator:ab13ccdf7a20ff57c124d4af5a87c93f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac88f18eab5904e9e58158fbc41651124"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac88f18eab5904e9e58158fbc41651124"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>_slaveSelectPin</b></td></tr>
<tr class="separator:ac88f18eab5904e9e58158fbc41651124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04c037baa4da200f80971fbda8ea7f9e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04c037baa4da200f80971fbda8ea7f9e"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>_interrupt</b></td></tr>
<tr class="separator:a04c037baa4da200f80971fbda8ea7f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acef584781b1d3906fa9c35b1eaba6a91"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="acef584781b1d3906fa9c35b1eaba6a91"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>_deviceType</b></td></tr>
<tr class="separator:acef584781b1d3906fa9c35b1eaba6a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e48acf3d51391f29c5dd13fb49b041"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa4e48acf3d51391f29c5dd13fb49b041"></a>
volatile uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>_bufLen</b></td></tr>
<tr class="separator:aa4e48acf3d51391f29c5dd13fb49b041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745a3a73bf08d0eb120c3421d9faaef9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a745a3a73bf08d0eb120c3421d9faaef9"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>_buf</b> [RF69_MAX_MESSAGE_LEN]</td></tr>
<tr class="separator:a745a3a73bf08d0eb120c3421d9faaef9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671c1e20cd112edfa1f1123845d93370"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a671c1e20cd112edfa1f1123845d93370"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>_thisAddress</b></td></tr>
<tr class="separator:a671c1e20cd112edfa1f1123845d93370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7556c6e2a2ed8211a8a3f7066a3ed8cf"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7556c6e2a2ed8211a8a3f7066a3ed8cf"></a>
boolean&#160;</td><td class="memItemRight" valign="bottom"><b>_promiscuous</b></td></tr>
<tr class="separator:a7556c6e2a2ed8211a8a3f7066a3ed8cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc29c939dcdbea27ff2cfbd481c91371"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adc29c939dcdbea27ff2cfbd481c91371"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>_rxHeaderTo</b></td></tr>
<tr class="separator:adc29c939dcdbea27ff2cfbd481c91371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703166f296d9271b3d2f25b8e2ac24fe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a703166f296d9271b3d2f25b8e2ac24fe"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>_rxHeaderFrom</b></td></tr>
<tr class="separator:a703166f296d9271b3d2f25b8e2ac24fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47787ec4523adf1edf8418bb7f256515"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a47787ec4523adf1edf8418bb7f256515"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>_rxHeaderId</b></td></tr>
<tr class="separator:a47787ec4523adf1edf8418bb7f256515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d95bdd868c0d89106ec6ca2ebe2cce3"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7d95bdd868c0d89106ec6ca2ebe2cce3"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>_rxHeaderFlags</b></td></tr>
<tr class="separator:a7d95bdd868c0d89106ec6ca2ebe2cce3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a478347d8d8b0ad12845accb4aa20cd60"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a478347d8d8b0ad12845accb4aa20cd60"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>_txHeaderTo</b></td></tr>
<tr class="separator:a478347d8d8b0ad12845accb4aa20cd60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915f516616b318669366cbaae6d2d1da"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a915f516616b318669366cbaae6d2d1da"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>_txHeaderFrom</b></td></tr>
<tr class="separator:a915f516616b318669366cbaae6d2d1da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c437ea09f17d00be4d16e2f335628f"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13c437ea09f17d00be4d16e2f335628f"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>_txHeaderId</b></td></tr>
<tr class="separator:a13c437ea09f17d00be4d16e2f335628f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036a51d5f00520312f24d9933c9df289"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a036a51d5f00520312f24d9933c9df289"></a>
uint8_t&#160;</td><td class="memItemRight" valign="bottom"><b>_txHeaderFlags</b></td></tr>
<tr class="separator:a036a51d5f00520312f24d9933c9df289"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070f991f7625adb9027e01b3d356d242"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a070f991f7625adb9027e01b3d356d242"></a>
volatile boolean&#160;</td><td class="memItemRight" valign="bottom"><b>_rxBufValid</b></td></tr>
<tr class="separator:a070f991f7625adb9027e01b3d356d242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bfa8cb98974d71d7a42bbce879af3a7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8bfa8cb98974d71d7a42bbce879af3a7"></a>
volatile boolean&#160;</td><td class="memItemRight" valign="bottom"><b>_txPacketSent</b></td></tr>
<tr class="separator:a8bfa8cb98974d71d7a42bbce879af3a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378dbe1101cab9f9140991dc10acb927"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a378dbe1101cab9f9140991dc10acb927"></a>
volatile uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>_rxBad</b></td></tr>
<tr class="separator:a378dbe1101cab9f9140991dc10acb927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d4280b698a3d0b8c2ed52b4323e24a"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a31d4280b698a3d0b8c2ed52b4323e24a"></a>
volatile uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>_rxGood</b></td></tr>
<tr class="separator:a31d4280b698a3d0b8c2ed52b4323e24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb6e937a6c8c84fa2fc3662bff55a28"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a7eb6e937a6c8c84fa2fc3662bff55a28"></a>
volatile uint16_t&#160;</td><td class="memItemRight" valign="bottom"><b>_txGood</b></td></tr>
<tr class="separator:a7eb6e937a6c8c84fa2fc3662bff55a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4b6ab3d431d0485cfbb6ed6428d766"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2d4b6ab3d431d0485cfbb6ed6428d766"></a>
volatile int8_t&#160;</td><td class="memItemRight" valign="bottom"><b>_lastRssi</b></td></tr>
<tr class="separator:a2d4b6ab3d431d0485cfbb6ed6428d766"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a123bf76e04cd7a904542c60bf7baaad2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a123bf76e04cd7a904542c60bf7baaad2"></a>
static <a class="el" href="classRF69.html">RF69</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classRF69.html#a123bf76e04cd7a904542c60bf7baaad2">_RF69ForInterrupt</a> [] = {0, 0, 0}</td></tr>
<tr class="memdesc:a123bf76e04cd7a904542c60bf7baaad2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of instances connected to interrupts 0 and 1. <br/></td></tr>
<tr class="separator:a123bf76e04cd7a904542c60bf7baaad2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Send and receive unaddressed, unreliable datagrams. </p>
<p>This base class provides basic functions for sending and receiving unaddressed, unreliable datagrams of arbitrary length to 64 octets per packet.</p>
<p>Subclasses may use this class to implement reliable, addressed datagrams and streams, mesh routers, repeaters, translators etc.</p>
<p>Naturally, for any 2 radios to communicate that must be configured to use the same frequence and modulation scheme. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a class="anchor" id="a4fe41b1fe75743906fa8501961ba6e6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classRF69.html#a4fe41b1fe75743906fa8501961ba6e6c">RF69::ModemConfigChoice</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Choices for <a class="el" href="classRF69.html#a7dd82b73f52f49f7bb31ab9c15feac3e">setModemConfig()</a> for a selected subset of common modulation types, and data rates. If you need another configuration, use the register calculator. and call <a class="el" href="classRF69.html#a80e394fe440b16bf88014120da926254">setModemRegisters()</a> with your desired settings These are indexes into MODEM_CONFIG_TABLE You have to construct these by hand, using the data from the <a class="el" href="classRF69.html" title="Send and receive unaddressed, unreliable datagrams. ">RF69</a> Datasheet :-( </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><em><a class="anchor" id="a4fe41b1fe75743906fa8501961ba6e6cabd5e2fe19f3efc50f97d825bc2694be7"></a>FSK_Rb2Fd5</em>&nbsp;</td><td class="fielddoc">
<p>FSK, No Manchester, Rb = 2kbs, Fd = 5kHz. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4fe41b1fe75743906fa8501961ba6e6ca7af1950ac5b3a5a684a8f61e5df65e7a"></a>FSK_Rb2_4Fd2_4</em>&nbsp;</td><td class="fielddoc">
<p>FSK, No Manchester, Rb = 2.4kbs, Fd = 2.4kHz. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4fe41b1fe75743906fa8501961ba6e6ca8710e687d9dd463a00048565782489c6"></a>FSK_Rb4_8Fd4_8</em>&nbsp;</td><td class="fielddoc">
<p>FSK, No Manchester, Rb = 4.8kbs, Fd = 4.8kHz. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4fe41b1fe75743906fa8501961ba6e6ca1241c5f1226a7ab7be2a202d54de6e56"></a>FSK_Rb9_6Fd9_6</em>&nbsp;</td><td class="fielddoc">
<p>FSK, No Manchester, Rb = 9.6kbs, Fd = 9.6kHz. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4fe41b1fe75743906fa8501961ba6e6ca115c8736a443b2828e3fbe23cc10692f"></a>FSK_Rb19_2Fd19_2</em>&nbsp;</td><td class="fielddoc">
<p>FSK, No Manchester, Rb = 19.2kbs, Fd = 19.2kHz. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4fe41b1fe75743906fa8501961ba6e6ca61b026d8fb0a9fd0758f55f1c1dc04a6"></a>FSK_Rb38_4Fd38_4</em>&nbsp;</td><td class="fielddoc">
<p>FSK, No Manchester, Rb = 38.4kbs, Fd = 38.4kHz. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4fe41b1fe75743906fa8501961ba6e6ca7f5ef500cb6713a46c760918d356a9b7"></a>FSK_Rb57_6Fd120</em>&nbsp;</td><td class="fielddoc">
<p>FSK, No Manchester, Rb = 57.6kbs, Fd = 120kHz. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4fe41b1fe75743906fa8501961ba6e6ca058590d23a8119ae285685525546e3b3"></a>FSK_Rb125Fd125</em>&nbsp;</td><td class="fielddoc">
<p>FSK, No Manchester, Rb = 125kbs, Fd = 125kHz. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4fe41b1fe75743906fa8501961ba6e6ca95e753e72e2d61da7b04740b15879aea"></a>FSK_Rb250Fd250</em>&nbsp;</td><td class="fielddoc">
<p>FSK, No Manchester, Rb = 250kbs, Fd = 250kHz. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4fe41b1fe75743906fa8501961ba6e6cab3e03baa1f07b8604e0b7fb67b079116"></a>FSK_Rb55555Fd50</em>&nbsp;</td><td class="fielddoc">
<p>FSK, No Manchester, Rb = 55555kbs,Fd = 50kHz for RFM69 lib compatibility. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4fe41b1fe75743906fa8501961ba6e6ca6898fa56805d7855633b1ff97d0e1948"></a>FSK_Rb_512Fd2_5</em>&nbsp;</td><td class="fielddoc">
<p>FSK, No Manchester, Rb = 512bs, Fd = 2.5kHz for POCSAG compatibility. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4fe41b1fe75743906fa8501961ba6e6caabce6b1ca98878dd76a52c4f75f32b73"></a>GFSK_Rb2Fd5</em>&nbsp;</td><td class="fielddoc">
<p>GFSK, No Manchester, Rb = 2kbs, Fd = 5kHz. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4fe41b1fe75743906fa8501961ba6e6cacc7c02340dac35e890ba461085f4f074"></a>GFSK_Rb2_4Fd2_4</em>&nbsp;</td><td class="fielddoc">
<p>GFSK, No Manchester, Rb = 2.4kbs, Fd = 2.4kHz. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4fe41b1fe75743906fa8501961ba6e6cac8d2080ca9afb27a08653ee667b90ea2"></a>GFSK_Rb4_8Fd4_8</em>&nbsp;</td><td class="fielddoc">
<p>GFSK, No Manchester, Rb = 4.8kbs, Fd = 4.8kHz. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4fe41b1fe75743906fa8501961ba6e6caf393f278340847169df3b8657a0db500"></a>GFSK_Rb9_6Fd9_6</em>&nbsp;</td><td class="fielddoc">
<p>GFSK, No Manchester, Rb = 9.6kbs, Fd = 9.6kHz. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4fe41b1fe75743906fa8501961ba6e6ca23b25283ff64ae1cdc0c49b70ea3c5f2"></a>GFSK_Rb19_2Fd19_2</em>&nbsp;</td><td class="fielddoc">
<p>GFSK, No Manchester, Rb = 19.2kbs, Fd = 19.2kHz. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4fe41b1fe75743906fa8501961ba6e6caac3d963dd38ade38b3c57c8b6abc7042"></a>GFSK_Rb38_4Fd38_4</em>&nbsp;</td><td class="fielddoc">
<p>GFSK, No Manchester, Rb = 38.4kbs, Fd = 38.4kHz. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4fe41b1fe75743906fa8501961ba6e6cae5fa7382aa009ee2310eb8ef76d438f0"></a>GFSK_Rb57_6Fd120</em>&nbsp;</td><td class="fielddoc">
<p>GFSK, No Manchester, Rb = 57.6kbs, Fd = 120kHz. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4fe41b1fe75743906fa8501961ba6e6ca89511e57ffa756795a47e3f8de0c6703"></a>GFSK_Rb125Fd125</em>&nbsp;</td><td class="fielddoc">
<p>GFSK, No Manchester, Rb = 125kbs, Fd = 125kHz. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4fe41b1fe75743906fa8501961ba6e6cacb1eb1dd9da5ef0e3b1973e95d7e0342"></a>GFSK_Rb250Fd250</em>&nbsp;</td><td class="fielddoc">
<p>GFSK, No Manchester, Rb = 250kbs, Fd = 250kHz. </p>
</td></tr>
<tr><td class="fieldname"><em><a class="anchor" id="a4fe41b1fe75743906fa8501961ba6e6cacd8a65a8d1c24266bfbe94c3af8d7571"></a>GFSK_Rb55555Fd50</em>&nbsp;</td><td class="fielddoc">
<p>GFSK, No Manchester, Rb = 55555kbs,Fd = 50kHz. </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a049055ffc82e4cbf172888ef8d9fec50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">RF69::RF69 </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>slaveSelectPin</em> = <code>SS</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>interrupt</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classGenericSPIClass.html">GenericSPIClass</a> *&#160;</td>
          <td class="paramname"><em>spi</em> = <code>&amp;Hardware_spi</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor. You can have multiple instances, but each instance must have its own interrupt and slave select pin. After constructing, you must call <a class="el" href="classRF69.html#afa9c067942baee08116409afe2b67c24">init()</a> to initialise the intnerface and the radio module </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">slaveSelectPin</td><td>the Arduino pin number of the output to use to select the RF22 before accessing it. Defaults to the normal SS pin for your Arduino (D10 for Diecimila, Uno etc, D53 for Mega) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">interrupt</td><td>The interrupt number to use. 0 - 2. Default is interrupt 0 (Arduino input pin 2) </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>Pointer to the SPI interface object to use. Defaults to the standard Arduino hardware SPI interface </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a1c61cfa294c0b5acba1983bb32c21d22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean RF69::available </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts the receiver and checks whether a received message is available. This can be called multiple times in a timeout loop </p>
<dl class="section return"><dt>Returns</dt><dd>true if a complete, valid message has been received and is able to be retrieved by <a class="el" href="classRF69.html#aff53e72d0c8c476ac42e37c8fc116795">recv()</a> </dd></dl>

<p>References <a class="el" href="classRF69.html#a53c35921a0d9a17aed3876492bbfe5d1">setModeRx()</a>.</p>

<p>Referenced by <a class="el" href="classRF69.html#aff53e72d0c8c476ac42e37c8fc116795">recv()</a>, <a class="el" href="classRF69.html#adee77eb9dcfc5e8e9c21bf279baae7f2">waitAvailable()</a>, and <a class="el" href="classRF69.html#ac9baf7e3b129c4309b845660bbc0fbae">waitAvailableTimeout()</a>.</p>

</div>
</div>
<a class="anchor" id="a73266d3e1faaae0449b11c6d99cf7f4f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RF69::handleInterrupt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This is a low level function to handle the interrupts for one instance of <a class="el" href="classRF69.html" title="Send and receive unaddressed, unreliable datagrams. ">RF69</a>. Called automatically by isr*() Should not need to be called. </p>

<p>References <a class="el" href="classRF69.html#ad893bc05e3f4f246551bbdfb2c4206ec">readFifo()</a>, <a class="el" href="classRF69.html#ad41e23fa6c86916ad9d31e43ed57a7da">setModeIdle()</a>, and <a class="el" href="classRF69.html#a6d194034f90f5cf0d41d5d05856dcf86">spiRead()</a>.</p>

<p>Referenced by <a class="el" href="classRF69.html#a581cae4586b7c45789e6d0e3fe8af29a">isr0()</a>, <a class="el" href="classRF69.html#aa3956c165111bfd20b62ff86cd89e488">isr1()</a>, and <a class="el" href="classRF69.html#a33923ae2eabbf82ee828664621b11ae4">isr2()</a>.</p>

</div>
</div>
<a class="anchor" id="a98dc29671c54b7f0666dac3bc8670a9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF69::headerFlags </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the FLAGS header of the last received message </p>
<dl class="section return"><dt>Returns</dt><dd>The FLAGS header </dd></dl>

</div>
</div>
<a class="anchor" id="a453dcbaa7090f63a45edf5ece0540f23"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF69::headerFrom </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the FROM header of the last received message </p>
<dl class="section return"><dt>Returns</dt><dd>The FROM header </dd></dl>

</div>
</div>
<a class="anchor" id="acd0d2d9449e29bb4708c420e108bd666"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF69::headerId </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the ID header of the last received message </p>
<dl class="section return"><dt>Returns</dt><dd>The ID header </dd></dl>

</div>
</div>
<a class="anchor" id="a31f227bd90024c4e766d64dff05d1443"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF69::headerTo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the TO header of the last received message </p>
<dl class="section return"><dt>Returns</dt><dd>The TO header </dd></dl>

</div>
</div>
<a class="anchor" id="afa9c067942baee08116409afe2b67c24"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean RF69::init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialises this instance and the radio module connected to it. The following steps are taken:</p>
<ul>
<li>Initialise the slave select pin and the SPI interface library</li>
<li>Software reset the <a class="el" href="classRF69.html" title="Send and receive unaddressed, unreliable datagrams. ">RF69</a> module</li>
<li>Checks the connected <a class="el" href="classRF69.html" title="Send and receive unaddressed, unreliable datagrams. ">RF69</a> module is either a RF69_DEVICE_TYPE_RX_TRX or a RF69_DEVICE_TYPE_TX</li>
<li>Attaches an interrupt handler</li>
<li>Configures the <a class="el" href="classRF69.html" title="Send and receive unaddressed, unreliable datagrams. ">RF69</a> module</li>
<li>Sets the frequncy to 434.0 MHz</li>
<li>Sets the modem data rate to FSK_Rb2_4Fd36 <dl class="section return"><dt>Returns</dt><dd>true if everything was successful </dd></dl>
</li>
</ul>

<p>References <a class="el" href="classRF69.html#a123bf76e04cd7a904542c60bf7baaad2">_RF69ForInterrupt</a>, <a class="el" href="classGenericSPIClass.html#a8e09529ae582d55f6440d33cebdf8ee6">GenericSPIClass::begin()</a>, <a class="el" href="classRF69.html#a4fe41b1fe75743906fa8501961ba6e6cabd5e2fe19f3efc50f97d825bc2694be7">FSK_Rb2Fd5</a>, <a class="el" href="classRF69.html#a581cae4586b7c45789e6d0e3fe8af29a">isr0()</a>, <a class="el" href="classRF69.html#aa3956c165111bfd20b62ff86cd89e488">isr1()</a>, <a class="el" href="classRF69.html#a33923ae2eabbf82ee828664621b11ae4">isr2()</a>, <a class="el" href="classRF69.html#af953ee17aca5392f1e62ea4fe690550a">reset()</a>, <a class="el" href="classGenericSPIClass.html#a0584e1d1fdc5841ea676b68e0d0750dc">GenericSPIClass::setBitOrder()</a>, <a class="el" href="classGenericSPIClass.html#afd6561628542975d6356e2727b7dbb85">GenericSPIClass::setClockDivider()</a>, <a class="el" href="classGenericSPIClass.html#a1a7a6b391735f2fff1eee8ee129719f4">GenericSPIClass::setDataMode()</a>, <a class="el" href="classRF69.html#a9f683737fd051836e31c9f21be405d75">setEncryptionKey()</a>, <a class="el" href="classRF69.html#abf68a80e6d95aaa543e4d26cb24c30d6">setFrequency()</a>, <a class="el" href="classRF69.html#ab3cb25ebd64c7d4bc28317a5e482611a">setMode()</a>, <a class="el" href="classRF69.html#a7dd82b73f52f49f7bb31ab9c15feac3e">setModemConfig()</a>, <a class="el" href="classRF69.html#ab953f1383c8c46e5cb69daa5e305d9f7">setPreambleLength()</a>, <a class="el" href="classRF69.html#a3f0fb435fda7f4fd8c42230063c0c0e3">setSyncWords()</a>, <a class="el" href="classRF69.html#a4b4adcf0c8bc0210dec7e98696dce596">setTxPower()</a>, <a class="el" href="classRF69.html#a6d194034f90f5cf0d41d5d05856dcf86">spiRead()</a>, and <a class="el" href="classRF69.html#a892117259efd9135448bee5529a31ac8">spiWrite()</a>.</p>

</div>
</div>
<a class="anchor" id="a9c2c18a64a1e41d3e29b59809efccd78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t RF69::lastRssi </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the most recent RSSI (Receiver Signal Strength Indicator). Usually it is the RSSI of the last received message, which is measured when the preamble is received. If you called readRssi() more recently, it will return that more recent value. </p>
<dl class="section return"><dt>Returns</dt><dd>The most recent RSSI measurement in dBm. </dd></dl>

</div>
</div>
<a class="anchor" id="a29a0faf47121e8431f2ab03f60ca0b6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF69::mode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the operating mode of the library. </p>
<dl class="section return"><dt>Returns</dt><dd>the current mode, one of RF69_MODE_* </dd></dl>

</div>
</div>
<a class="anchor" id="a7fcc3f2b042d0173956d16690b056c64"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RF69::printBuffer </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>prompt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Prints a data buffer in HEX. For diagnostic use </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">prompt</td><td>string to preface the print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Location of the buffer to print </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Length of the buffer in octets. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad893bc05e3f4f246551bbdfb2c4206ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RF69::readFifo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Low level function to read the FIFO and put the received data into the receive buffer Should not need to be called by user code </p>

<p>References <a class="el" href="classGenericSPIClass.html#af34db32b942caedb2436cb60c9bf7ccc">GenericSPIClass::transfer()</a>.</p>

<p>Referenced by <a class="el" href="classRF69.html#a73266d3e1faaae0449b11c6d99cf7f4f">handleInterrupt()</a>.</p>

</div>
</div>
<a class="anchor" id="aff53e72d0c8c476ac42e37c8fc116795"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean RF69::recv </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Turns the receiver on if it not already on. If there is a valid message available, copy it to buf and return true else return false. If a message is copied, *len is set to the length (Caution, 0 length messages are permitted). You should be sure to call this function frequently enough to not miss any messages It is recommended that you call it in your main loop. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>Location to copy the received message </td></tr>
    <tr><td class="paramdir">[in,out]</td><td class="paramname">len</td><td>Pointer to available space in buf. Set to the actual number of octets copied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a valid message was copied to buf </dd></dl>

<p>References <a class="el" href="classRF69.html#a1c61cfa294c0b5acba1983bb32c21d22">available()</a>.</p>

</div>
</div>
<a class="anchor" id="af953ee17aca5392f1e62ea4fe690550a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF69::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Issues a software reset to the RF22 module. Blocks for 1ms to ensure the reset is complete. </p>

<p>Referenced by <a class="el" href="classRF69.html#afa9c067942baee08116409afe2b67c24">init()</a>.</p>

</div>
</div>
<a class="anchor" id="af88c2534ddf80cb1df4b7c777c0d55e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t RF69::rssiRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads and returns the current RSSI value. Causes the current signal strength to be measured and returned If you want to find the RSSI of the last received message, use <a class="el" href="classRF69.html#a9c2c18a64a1e41d3e29b59809efccd78">lastRssi()</a> instead. </p>
<dl class="section return"><dt>Returns</dt><dd>The current RSSI value on units of 0.5dB. </dd></dl>

<p>References <a class="el" href="classRF69.html#a6d194034f90f5cf0d41d5d05856dcf86">spiRead()</a>, and <a class="el" href="classRF69.html#a892117259efd9135448bee5529a31ac8">spiWrite()</a>.</p>

</div>
</div>
<a class="anchor" id="aabb5110b9710f0db13582fec63ed9635"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean RF69::send </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Waits until any previous transmit packet is finished being transmitted with <a class="el" href="classRF69.html#a003312d212e2090b001c718ed96fb850">waitPacketSent()</a>. Then loads a message into the transmitter and starts the transmitter. Note that a message length of 0 is NOT permitted. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>Array of data to be sent </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes of data to send (&gt; 0) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the message length was valid and it was correctly queued for transmit </dd></dl>

<p>References <a class="el" href="classRF69.html#ad41e23fa6c86916ad9d31e43ed57a7da">setModeIdle()</a>, <a class="el" href="classRF69.html#ae7444f35ee3445dbf0d5e781b5e95738">setModeTx()</a>, <a class="el" href="classGenericSPIClass.html#af34db32b942caedb2436cb60c9bf7ccc">GenericSPIClass::transfer()</a>, and <a class="el" href="classRF69.html#a003312d212e2090b001c718ed96fb850">waitPacketSent()</a>.</p>

</div>
</div>
<a class="anchor" id="a9f683737fd051836e31c9f21be405d75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF69::setEncryptionKey </td>
          <td>(</td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>key</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Enables AES encryption and sets the AES encryption key, used to encrypt and decrypt all messages. The default is disabled. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">key</td><td>The key to use. Must be 16 bytes long. The same key must be installed in other instances of <a class="el" href="classRF69.html" title="Send and receive unaddressed, unreliable datagrams. ">RF69</a>, otherwise communications will not work correctly. If key is NULL, encryption is disabled. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classRF69.html#abb0340012327cddd9e502cbe33ca7cf9">spiBurstWrite()</a>, <a class="el" href="classRF69.html#a6d194034f90f5cf0d41d5d05856dcf86">spiRead()</a>, and <a class="el" href="classRF69.html#a892117259efd9135448bee5529a31ac8">spiWrite()</a>.</p>

<p>Referenced by <a class="el" href="classRF69.html#afa9c067942baee08116409afe2b67c24">init()</a>.</p>

</div>
</div>
<a class="anchor" id="abf68a80e6d95aaa543e4d26cb24c30d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean RF69::setFrequency </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>centre</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>afcPullInRange</em> = <code>0.05</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the transmitter and receiver centre frequency </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">centre</td><td>Frequency in MHz. 240.0 to 960.0. Caution, <a class="el" href="classRF69.html" title="Send and receive unaddressed, unreliable datagrams. ">RF69</a> comes in several different frequency ranges, and setting a frequency outside that range of your radio will probably not work </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">afcPullInRange</td><td>Not used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the selected frquency centre is within range </dd></dl>

<p>References <a class="el" href="classRF69.html#a892117259efd9135448bee5529a31ac8">spiWrite()</a>.</p>

<p>Referenced by <a class="el" href="classRF69.html#afa9c067942baee08116409afe2b67c24">init()</a>.</p>

</div>
</div>
<a class="anchor" id="a99b3a392f73cac36c5207516f53c3a00"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RF69::setHeaderFlags </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>flags</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the FLAGS header to be sent in all subsequent messages </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>The new FLAGS header value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af790da935407e77aff4699cf245fcd0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RF69::setHeaderFrom </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the FROM header to be sent in all subsequent messages </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">from</td><td>The new FROM header value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8ff30c728cb4b845d370e63937ac04f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RF69::setHeaderId </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the ID header to be sent in all subsequent messages </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>The new ID header value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a2ec70961e68478220352522bb4654ca1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void RF69::setHeaderTo </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>to</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the TO header to be sent in all subsequent messages </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>The new TO header value </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ab3cb25ebd64c7d4bc28317a5e482611a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF69::setMode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>mode</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the parameters for the <a class="el" href="classRF69.html" title="Send and receive unaddressed, unreliable datagrams. ">RF69</a> OPMODE. This is a low level device access funciton, and should not normally ned to be used by user code. Instead can use stModeRx(), <a class="el" href="classRF69.html#ae7444f35ee3445dbf0d5e781b5e95738">setModeTx()</a>, <a class="el" href="classRF69.html#ad41e23fa6c86916ad9d31e43ed57a7da">setModeIdle()</a> </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mode</td><td><a class="el" href="classRF69.html" title="Send and receive unaddressed, unreliable datagrams. ">RF69</a> OPMODE to set, one of RF69_OPMODE_MODE_*. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classRF69.html#a6d194034f90f5cf0d41d5d05856dcf86">spiRead()</a>, and <a class="el" href="classRF69.html#a892117259efd9135448bee5529a31ac8">spiWrite()</a>.</p>

<p>Referenced by <a class="el" href="classRF69.html#afa9c067942baee08116409afe2b67c24">init()</a>, <a class="el" href="classRF69.html#ad41e23fa6c86916ad9d31e43ed57a7da">setModeIdle()</a>, <a class="el" href="classRF69.html#a53c35921a0d9a17aed3876492bbfe5d1">setModeRx()</a>, and <a class="el" href="classRF69.html#ae7444f35ee3445dbf0d5e781b5e95738">setModeTx()</a>.</p>

</div>
</div>
<a class="anchor" id="ad41e23fa6c86916ad9d31e43ed57a7da"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF69::setModeIdle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If current mode is Rx or Tx changes it to Idle. If the transmitter or receiver is running, disables them. </p>

<p>References <a class="el" href="classRF69.html#ab3cb25ebd64c7d4bc28317a5e482611a">setMode()</a>.</p>

<p>Referenced by <a class="el" href="classRF69.html#a73266d3e1faaae0449b11c6d99cf7f4f">handleInterrupt()</a>, and <a class="el" href="classRF69.html#aabb5110b9710f0db13582fec63ed9635">send()</a>.</p>

</div>
</div>
<a class="anchor" id="a7dd82b73f52f49f7bb31ab9c15feac3e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean RF69::setModemConfig </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classRF69.html#a4fe41b1fe75743906fa8501961ba6e6c">ModemConfigChoice</a>&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Select one of the predefined modem configurations. If you need a modem configuration not provided here, use <a class="el" href="classRF69.html#a80e394fe440b16bf88014120da926254">setModemRegisters()</a> with your own <a class="el" href="structRF69_1_1ModemConfig.html" title="Defines register values for a set of modem configuration registers. ">ModemConfig</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">index</td><td>The configuration choice. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if index is a valid choice. </dd></dl>

<p>References <a class="el" href="classRF69.html#a80e394fe440b16bf88014120da926254">setModemRegisters()</a>.</p>

<p>Referenced by <a class="el" href="classRF69.html#afa9c067942baee08116409afe2b67c24">init()</a>.</p>

</div>
</div>
<a class="anchor" id="a80e394fe440b16bf88014120da926254"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF69::setModemRegisters </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structRF69_1_1ModemConfig.html">ModemConfig</a> *&#160;</td>
          <td class="paramname"><em>config</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets all the registered required to configure the data modem in the <a class="el" href="classRF69.html" title="Send and receive unaddressed, unreliable datagrams. ">RF69</a>, including the data rate, bandwidths etc. You cas use this to configure the modem with custom configurations if none of the canned configurations in ModemConfigChoice suit you. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">config</td><td>A <a class="el" href="structRF69_1_1ModemConfig.html" title="Defines register values for a set of modem configuration registers. ">ModemConfig</a> structure containing values for the modem configuration registers. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="structRF69_1_1ModemConfig.html#a0da049e72dcb346f268820e003fc075b">RF69::ModemConfig::reg_02</a>, <a class="el" href="structRF69_1_1ModemConfig.html#a7ab1f1825cc2a5ef5b522ec26012884a">RF69::ModemConfig::reg_19</a>, <a class="el" href="structRF69_1_1ModemConfig.html#a497a0b0ef9fc535ee55c1327324cd2be">RF69::ModemConfig::reg_37</a>, <a class="el" href="classRF69.html#abb0340012327cddd9e502cbe33ca7cf9">spiBurstWrite()</a>, and <a class="el" href="classRF69.html#a892117259efd9135448bee5529a31ac8">spiWrite()</a>.</p>

<p>Referenced by <a class="el" href="classRF69.html#a7dd82b73f52f49f7bb31ab9c15feac3e">setModemConfig()</a>.</p>

</div>
</div>
<a class="anchor" id="a53c35921a0d9a17aed3876492bbfe5d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF69::setModeRx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If current mode is Tx or Idle, changes it to Rx. Starts the receiver in the <a class="el" href="classRF69.html" title="Send and receive unaddressed, unreliable datagrams. ">RF69</a>. </p>

<p>References <a class="el" href="classRF69.html#ab3cb25ebd64c7d4bc28317a5e482611a">setMode()</a>, and <a class="el" href="classRF69.html#a892117259efd9135448bee5529a31ac8">spiWrite()</a>.</p>

<p>Referenced by <a class="el" href="classRF69.html#a1c61cfa294c0b5acba1983bb32c21d22">available()</a>.</p>

</div>
</div>
<a class="anchor" id="ae7444f35ee3445dbf0d5e781b5e95738"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF69::setModeTx </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If current mode is Rx or Idle, changes it to Rx. F Starts the transmitter in the <a class="el" href="classRF69.html" title="Send and receive unaddressed, unreliable datagrams. ">RF69</a>. </p>

<p>References <a class="el" href="classRF69.html#ab3cb25ebd64c7d4bc28317a5e482611a">setMode()</a>, and <a class="el" href="classRF69.html#a892117259efd9135448bee5529a31ac8">spiWrite()</a>.</p>

<p>Referenced by <a class="el" href="classRF69.html#aabb5110b9710f0db13582fec63ed9635">send()</a>.</p>

</div>
</div>
<a class="anchor" id="ab953f1383c8c46e5cb69daa5e305d9f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF69::setPreambleLength </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>bytes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the length of the preamble in bytes. Caution: this should be set to the same value on all nodes in your network. Default is 4. Sets the message preamble length in REG_0?_PREAMBLE?SB </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">bytes</td><td>Preamble length in bytes. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classRF69.html#a892117259efd9135448bee5529a31ac8">spiWrite()</a>.</p>

<p>Referenced by <a class="el" href="classRF69.html#afa9c067942baee08116409afe2b67c24">init()</a>.</p>

</div>
</div>
<a class="anchor" id="a6d3d3e65d7e23374362fd2cd3bdf80a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF69::setPromiscuous </td>
          <td>(</td>
          <td class="paramtype">boolean&#160;</td>
          <td class="paramname"><em>promiscuous</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tells the receiver to accept messages with any TO address, not just messages addressed to thisAddress or the broadcast address </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">promiscuous</td><td>true if you wish to receive messages with any TO address </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3f0fb435fda7f4fd8c42230063c0c0e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF69::setSyncWords </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>syncWords</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the sync words for transmit and receive Caution: SyncWords should be set to the same value on all nodes in your network. Nodes with different SyncWords set will never receive each others messages, so different SyncWords can be used to isolate different networks from each other. Default is { 0x2d, 0xd4 }. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">syncWords</td><td>Array of sync words, 1 to 4 octets long. NULL if no sync words to be used. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of sync words to set, 1 to 4. 0 if no sync words to be used. </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classRF69.html#abb0340012327cddd9e502cbe33ca7cf9">spiBurstWrite()</a>, <a class="el" href="classRF69.html#a6d194034f90f5cf0d41d5d05856dcf86">spiRead()</a>, and <a class="el" href="classRF69.html#a892117259efd9135448bee5529a31ac8">spiWrite()</a>.</p>

<p>Referenced by <a class="el" href="classRF69.html#afa9c067942baee08116409afe2b67c24">init()</a>.</p>

</div>
</div>
<a class="anchor" id="a2fc06d71aaa24e9781bb8984b50dc6d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF69::setThisAddress </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>thisAddress</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the address of this node. Defaults to 0xFF. Subclasses or the user may want to change this. This will be used to test the adddress in incoming messages. In non-promiscuous mode, only messages with a TO header the same as thisAddress or the broadcast addess (0xFF) will be accepted. In promiscuous mode, all messages will be accepted regardless of the TO header. In a conventional multinode system, all nodes will have a unique address (which you could store in EEPROM). You would normally set the header FROM address to be the same as thisAddress (though you dont have to, allowing the possibilty of address spoofing). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">thisAddress</td><td>The address of this node. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a4b4adcf0c8bc0210dec7e98696dce596"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF69::setTxPower </td>
          <td>(</td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>power</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets the transmitter power output level. Be a good neighbour and set the lowest power level you need. Caution: legal power limits may apply in certain countries. After <a class="el" href="classRF69.html#afa9c067942baee08116409afe2b67c24">init()</a>, the power will be set to 13dBm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">power</td><td>Transmitter power level in dBm from -18dBm to +13dB (higher powers may be available depending on which version of <a class="el" href="classRF69.html" title="Send and receive unaddressed, unreliable datagrams. ">RF69</a> radio you have). </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classRF69.html#a892117259efd9135448bee5529a31ac8">spiWrite()</a>.</p>

<p>Referenced by <a class="el" href="classRF69.html#afa9c067942baee08116409afe2b67c24">init()</a>.</p>

</div>
</div>
<a class="anchor" id="a9e9ec98fc751bc26e9c009251c42da9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF69::spiBurstRead </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a number of consecutive registers from the <a class="el" href="classRF69.html" title="Send and receive unaddressed, unreliable datagrams. ">RF69</a> using burst read mode </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>Register number of the first register, one of RF69_REG_* </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dest</td><td>Array to write the register values to. Must be at least len bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes to read </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classGenericSPIClass.html#af34db32b942caedb2436cb60c9bf7ccc">GenericSPIClass::transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="abb0340012327cddd9e502cbe33ca7cf9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF69::spiBurstWrite </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write a number of consecutive registers using burst write mode </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>Register number of the first register, one of RF69_REG_* </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src</td><td>Array of new register values to write. Must be at least len bytes </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>Number of bytes to write </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classGenericSPIClass.html#af34db32b942caedb2436cb60c9bf7ccc">GenericSPIClass::transfer()</a>.</p>

<p>Referenced by <a class="el" href="classRF69.html#a9f683737fd051836e31c9f21be405d75">setEncryptionKey()</a>, <a class="el" href="classRF69.html#a80e394fe440b16bf88014120da926254">setModemRegisters()</a>, and <a class="el" href="classRF69.html#a3f0fb435fda7f4fd8c42230063c0c0e3">setSyncWords()</a>.</p>

</div>
</div>
<a class="anchor" id="a6d194034f90f5cf0d41d5d05856dcf86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t RF69::spiRead </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads a single register from the RF22 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>Register number, one of RF22_REG_* </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The value of the register </dd></dl>

<p>References <a class="el" href="classGenericSPIClass.html#af34db32b942caedb2436cb60c9bf7ccc">GenericSPIClass::transfer()</a>.</p>

<p>Referenced by <a class="el" href="classRF69.html#a73266d3e1faaae0449b11c6d99cf7f4f">handleInterrupt()</a>, <a class="el" href="classRF69.html#afa9c067942baee08116409afe2b67c24">init()</a>, <a class="el" href="classRF69.html#af88c2534ddf80cb1df4b7c777c0d55e4">rssiRead()</a>, <a class="el" href="classRF69.html#a9f683737fd051836e31c9f21be405d75">setEncryptionKey()</a>, <a class="el" href="classRF69.html#ab3cb25ebd64c7d4bc28317a5e482611a">setMode()</a>, <a class="el" href="classRF69.html#a3f0fb435fda7f4fd8c42230063c0c0e3">setSyncWords()</a>, and <a class="el" href="classRF69.html#adbba30813b20d1b52aa540a3bb0838a7">temperatureRead()</a>.</p>

</div>
</div>
<a class="anchor" id="a892117259efd9135448bee5529a31ac8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF69::spiWrite </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>reg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Writes a single byte to the RF22 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">reg</td><td>Register number, one of RF69_REG_* </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>The value to write </td></tr>
  </table>
  </dd>
</dl>

<p>References <a class="el" href="classGenericSPIClass.html#af34db32b942caedb2436cb60c9bf7ccc">GenericSPIClass::transfer()</a>.</p>

<p>Referenced by <a class="el" href="classRF69.html#afa9c067942baee08116409afe2b67c24">init()</a>, <a class="el" href="classRF69.html#af88c2534ddf80cb1df4b7c777c0d55e4">rssiRead()</a>, <a class="el" href="classRF69.html#a9f683737fd051836e31c9f21be405d75">setEncryptionKey()</a>, <a class="el" href="classRF69.html#abf68a80e6d95aaa543e4d26cb24c30d6">setFrequency()</a>, <a class="el" href="classRF69.html#ab3cb25ebd64c7d4bc28317a5e482611a">setMode()</a>, <a class="el" href="classRF69.html#a80e394fe440b16bf88014120da926254">setModemRegisters()</a>, <a class="el" href="classRF69.html#a53c35921a0d9a17aed3876492bbfe5d1">setModeRx()</a>, <a class="el" href="classRF69.html#ae7444f35ee3445dbf0d5e781b5e95738">setModeTx()</a>, <a class="el" href="classRF69.html#ab953f1383c8c46e5cb69daa5e305d9f7">setPreambleLength()</a>, <a class="el" href="classRF69.html#a3f0fb435fda7f4fd8c42230063c0c0e3">setSyncWords()</a>, <a class="el" href="classRF69.html#a4b4adcf0c8bc0210dec7e98696dce596">setTxPower()</a>, and <a class="el" href="classRF69.html#adbba30813b20d1b52aa540a3bb0838a7">temperatureRead()</a>.</p>

</div>
</div>
<a class="anchor" id="adbba30813b20d1b52aa540a3bb0838a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t RF69::temperatureRead </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the on-chip temperature sensor. The <a class="el" href="classRF69.html" title="Send and receive unaddressed, unreliable datagrams. ">RF69</a> must be in Idle mode (= <a class="el" href="classRF69.html" title="Send and receive unaddressed, unreliable datagrams. ">RF69</a> Standby) to measure temperature. The measurement is uncalibrated and without calibration, you can expectit to be far from correct. </p>
<dl class="section return"><dt>Returns</dt><dd>The measured temperature, in degrees C from -40 to 85 (uncalibrated) </dd></dl>

<p>References <a class="el" href="classRF69.html#a6d194034f90f5cf0d41d5d05856dcf86">spiRead()</a>, and <a class="el" href="classRF69.html#a892117259efd9135448bee5529a31ac8">spiWrite()</a>.</p>

</div>
</div>
<a class="anchor" id="adee77eb9dcfc5e8e9c21bf279baae7f2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF69::waitAvailable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts the receiver and blocks until a valid received message is available. </p>

<p>References <a class="el" href="classRF69.html#a1c61cfa294c0b5acba1983bb32c21d22">available()</a>.</p>

</div>
</div>
<a class="anchor" id="ac9baf7e3b129c4309b845660bbc0fbae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF69::waitAvailableTimeout </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Starts the receiver and blocks until a received message is available or a timeout </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Maximum time to wait in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if a message is available </dd></dl>

<p>References <a class="el" href="classRF69.html#a1c61cfa294c0b5acba1983bb32c21d22">available()</a>.</p>

</div>
</div>
<a class="anchor" id="a003312d212e2090b001c718ed96fb850"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void RF69::waitPacketSent </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Blocks until the <a class="el" href="classRF69.html" title="Send and receive unaddressed, unreliable datagrams. ">RF69</a> is not in mode RF69_MODE_TX (ie until the <a class="el" href="classRF69.html" title="Send and receive unaddressed, unreliable datagrams. ">RF69</a> is not transmitting). This effectively waits until any previous transmit packet is finished being transmitted. </p>

<p>Referenced by <a class="el" href="classRF69.html#aabb5110b9710f0db13582fec63ed9635">send()</a>.</p>

</div>
</div>
<a class="anchor" id="a4c3e272a1e9c6fa68505828b7920425a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool RF69::waitPacketSent </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>timeout</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Blocks until the <a class="el" href="classRF69.html" title="Send and receive unaddressed, unreliable datagrams. ">RF69</a> is not in mode RF69_MODE_TX (ie until the <a class="el" href="classRF69.html" title="Send and receive unaddressed, unreliable datagrams. ">RF69</a> is not transmitting) or until the timeout occuers, whichever happens first </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>Maximum time to wait in milliseconds. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the <a class="el" href="classRF69.html" title="Send and receive unaddressed, unreliable datagrams. ">RF69</a> is not transmitting any more </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li><a class="el" href="RF69_8h_source.html">RF69.h</a></li>
<li>RF69.cpp</li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.5
</small></address>
</body>
</html>
